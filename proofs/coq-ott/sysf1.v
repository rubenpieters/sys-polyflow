(* generated by Ott 0.31, locally-nameless from: sysf1.ott *)
Require Import Bool.
Require Import Metalib.Metatheory.
Require Import List.
Require Import Ott.ott_list_core.
(** syntax *)
Definition typevar : Set := var. (*r type variables *)
Definition termvar : Set := var. (*r term variables *)

Inductive typ : Set :=  (*r types *)
 | typ_tvar_b (_:nat)
 | typ_tvar_f (X:typevar)
 | typ_top : typ (*r top type *)
 | typ_arrow (T1:typ) (T2:typ) (*r function types *)
 | typ_forall (T1:typ) (T2:typ)
 | typ_true : typ
 | typ_false : typ
 | typ_union (T1:typ) (T2:typ).

Inductive binding : Set :=  (*r bindings *)
 | bind_typ (T:typ)
 | bind_sub (T:typ).

Inductive exp : Set :=  (*r expressions *)
 | var_b (_:nat) (*r variables *)
 | var_f (x:termvar) (*r variables *)
 | abs (T:typ) (e:exp) (*r abstractions *)
 | tabs (T:typ) (e:exp) (*r type abstraction *)
 | tapp (e:exp) (T:typ) (*r type applications *)
 | app (e1:exp) (e2:exp) (*r applications *)
 | true : exp
 | false : exp
 | ite (e1:exp) (e2:exp) (e3:exp)
 | eq (e1:exp) (e2:exp)
 | and (e1:exp) (e2:exp).

Definition ctx : Set := list ( atom * binding ).

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_typ_wrt_typ_rec (k:nat) (T_5:typ) (T__6:typ) {struct T__6}: typ :=
  match T__6 with
  | (typ_tvar_b nat) => if (k === nat) then T_5 else (typ_tvar_b nat)
  | (typ_tvar_f X) => typ_tvar_f X
  | typ_top => typ_top 
  | (typ_arrow T1 T2) => typ_arrow (open_typ_wrt_typ_rec k T_5 T1) (open_typ_wrt_typ_rec k T_5 T2)
  | (typ_forall T1 T2) => typ_forall (open_typ_wrt_typ_rec k T_5 T1) (open_typ_wrt_typ_rec (S k) T_5 T2)
  | typ_true => typ_true 
  | typ_false => typ_false 
  | (typ_union T1 T2) => typ_union (open_typ_wrt_typ_rec k T_5 T1) (open_typ_wrt_typ_rec k T_5 T2)
end.

Fixpoint open_exp_wrt_typ_rec (k:nat) (T5:typ) (e_5:exp) {struct e_5}: exp :=
  match e_5 with
  | (var_b nat) => var_b nat
  | (var_f x) => var_f x
  | (abs T e) => abs (open_typ_wrt_typ_rec k T5 T) (open_exp_wrt_typ_rec k T5 e)
  | (tabs T e) => tabs (open_typ_wrt_typ_rec k T5 T) (open_exp_wrt_typ_rec (S k) T5 e)
  | (tapp e T) => tapp (open_exp_wrt_typ_rec k T5 e) (open_typ_wrt_typ_rec k T5 T)
  | (app e1 e2) => app (open_exp_wrt_typ_rec k T5 e1) (open_exp_wrt_typ_rec k T5 e2)
  | true => true 
  | false => false 
  | (ite e1 e2 e3) => ite (open_exp_wrt_typ_rec k T5 e1) (open_exp_wrt_typ_rec k T5 e2) (open_exp_wrt_typ_rec k T5 e3)
  | (eq e1 e2) => eq (open_exp_wrt_typ_rec k T5 e1) (open_exp_wrt_typ_rec k T5 e2)
  | (and e1 e2) => and (open_exp_wrt_typ_rec k T5 e1) (open_exp_wrt_typ_rec k T5 e2)
end.

Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | (var_b nat) => if (k === nat) then e_5 else (var_b nat)
  | (var_f x) => var_f x
  | (abs T e) => abs T (open_exp_wrt_exp_rec (S k) e_5 e)
  | (tabs T e) => tabs T (open_exp_wrt_exp_rec k e_5 e)
  | (tapp e T) => tapp (open_exp_wrt_exp_rec k e_5 e) T
  | (app e1 e2) => app (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | true => true 
  | false => false 
  | (ite e1 e2 e3) => ite (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2) (open_exp_wrt_exp_rec k e_5 e3)
  | (eq e1 e2) => eq (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
  | (and e1 e2) => and (open_exp_wrt_exp_rec k e_5 e1) (open_exp_wrt_exp_rec k e_5 e2)
end.

Definition open_binding_wrt_typ_rec (k:nat) (T5:typ) (b5:binding) : binding :=
  match b5 with
  | (bind_typ T) => bind_typ (open_typ_wrt_typ_rec k T5 T)
  | (bind_sub T) => bind_sub (open_typ_wrt_typ_rec k T5 T)
end.

Definition open_exp_wrt_typ T5 e_5 := open_exp_wrt_typ_rec 0 e_5 T5.

Definition open_typ_wrt_typ T_5 T__6 := open_typ_wrt_typ_rec 0 T__6 T_5.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

Definition open_binding_wrt_typ T5 b5 := open_binding_wrt_typ_rec 0 b5 T5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_typ *)
Inductive lc_typ : typ -> Prop :=    (* defn lc_typ *)
 | lc_typ_tvar_f : forall (X:typevar),
     (lc_typ (typ_tvar_f X))
 | lc_typ_top : 
     (lc_typ typ_top)
 | lc_typ_arrow : forall (T1 T2:typ),
     (lc_typ T1) ->
     (lc_typ T2) ->
     (lc_typ (typ_arrow T1 T2))
 | lc_typ_forall : forall (L:vars) (T1 T2:typ),
     (lc_typ T1) ->
      ( forall X , X \notin  L  -> lc_typ  ( open_typ_wrt_typ T2 (typ_tvar_f X) )  )  ->
     (lc_typ (typ_forall T1 T2))
 | lc_typ_true : 
     (lc_typ typ_true)
 | lc_typ_false : 
     (lc_typ typ_false)
 | lc_typ_union : forall (T1 T2:typ),
     (lc_typ T1) ->
     (lc_typ T2) ->
     (lc_typ (typ_union T1 T2)).

(* defns LC_binding *)
Inductive lc_binding : binding -> Prop :=    (* defn lc_binding *)
 | lc_bind_typ : forall (T:typ),
     (lc_typ T) ->
     (lc_binding (bind_typ T))
 | lc_bind_sub : forall (T:typ),
     (lc_typ T) ->
     (lc_binding (bind_sub T)).

(* defns LC_exp *)
Inductive lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_var_f : forall (x:termvar),
     (lc_exp (var_f x))
 | lc_abs : forall (L:vars) (T:typ) (e:exp),
     (lc_typ T) ->
      ( forall x , x \notin  L  -> lc_exp  ( open_exp_wrt_exp e (var_f x) )  )  ->
     (lc_exp (abs T e))
 | lc_tabs : forall (L:vars) (T:typ) (e:exp),
     (lc_typ T) ->
      ( forall X , X \notin  L  -> lc_exp  ( open_exp_wrt_typ e (typ_tvar_f X) )  )  ->
     (lc_exp (tabs T e))
 | lc_tapp : forall (e:exp) (T:typ),
     (lc_exp e) ->
     (lc_typ T) ->
     (lc_exp (tapp e T))
 | lc_app : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (app e1 e2))
 | lc_true : 
     (lc_exp true)
 | lc_false : 
     (lc_exp false)
 | lc_ite : forall (e1 e2 e3:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp e3) ->
     (lc_exp (ite e1 e2 e3))
 | lc_eq : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (eq e1 e2))
 | lc_and : forall (e1 e2:exp),
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (and e1 e2)).
(** free variables *)
Fixpoint fv_tt_typ (T_5:typ) : vars :=
  match T_5 with
  | (typ_tvar_b nat) => {}
  | (typ_tvar_f X) => {{X}}
  | typ_top => {}
  | (typ_arrow T1 T2) => (fv_tt_typ T1) \u (fv_tt_typ T2)
  | (typ_forall T1 T2) => (fv_tt_typ T1) \u (fv_tt_typ T2)
  | typ_true => {}
  | typ_false => {}
  | (typ_union T1 T2) => (fv_tt_typ T1) \u (fv_tt_typ T2)
end.

Fixpoint fv_tt_exp (e_5:exp) : vars :=
  match e_5 with
  | (var_b nat) => {}
  | (var_f x) => {}
  | (abs T e) => (fv_tt_typ T) \u (fv_tt_exp e)
  | (tabs T e) => (fv_tt_typ T) \u (fv_tt_exp e)
  | (tapp e T) => (fv_tt_exp e) \u (fv_tt_typ T)
  | (app e1 e2) => (fv_tt_exp e1) \u (fv_tt_exp e2)
  | true => {}
  | false => {}
  | (ite e1 e2 e3) => (fv_tt_exp e1) \u (fv_tt_exp e2) \u (fv_tt_exp e3)
  | (eq e1 e2) => (fv_tt_exp e1) \u (fv_tt_exp e2)
  | (and e1 e2) => (fv_tt_exp e1) \u (fv_tt_exp e2)
end.

Fixpoint fv_ee_exp (e_5:exp) : vars :=
  match e_5 with
  | (var_b nat) => {}
  | (var_f x) => {{x}}
  | (abs T e) => (fv_ee_exp e)
  | (tabs T e) => (fv_ee_exp e)
  | (tapp e T) => (fv_ee_exp e)
  | (app e1 e2) => (fv_ee_exp e1) \u (fv_ee_exp e2)
  | true => {}
  | false => {}
  | (ite e1 e2 e3) => (fv_ee_exp e1) \u (fv_ee_exp e2) \u (fv_ee_exp e3)
  | (eq e1 e2) => (fv_ee_exp e1) \u (fv_ee_exp e2)
  | (and e1 e2) => (fv_ee_exp e1) \u (fv_ee_exp e2)
end.

Definition fv_tt_binding (b5:binding) : vars :=
  match b5 with
  | (bind_typ T) => (fv_tt_typ T)
  | (bind_sub T) => (fv_tt_typ T)
end.

(** substitutions *)
Fixpoint Tsubst_typ (T_5:typ) (X5:typevar) (T__6:typ) {struct T__6} : typ :=
  match T__6 with
  | (typ_tvar_b nat) => typ_tvar_b nat
  | (typ_tvar_f X) => (if eq_var X X5 then T_5 else (typ_tvar_f X))
  | typ_top => typ_top 
  | (typ_arrow T1 T2) => typ_arrow (Tsubst_typ T_5 X5 T1) (Tsubst_typ T_5 X5 T2)
  | (typ_forall T1 T2) => typ_forall (Tsubst_typ T_5 X5 T1) (Tsubst_typ T_5 X5 T2)
  | typ_true => typ_true 
  | typ_false => typ_false 
  | (typ_union T1 T2) => typ_union (Tsubst_typ T_5 X5 T1) (Tsubst_typ T_5 X5 T2)
end.

Fixpoint Tsubst_exp (T5:typ) (X5:typevar) (e_5:exp) {struct e_5} : exp :=
  match e_5 with
  | (var_b nat) => var_b nat
  | (var_f x) => var_f x
  | (abs T e) => abs (Tsubst_typ T5 X5 T) (Tsubst_exp T5 X5 e)
  | (tabs T e) => tabs (Tsubst_typ T5 X5 T) (Tsubst_exp T5 X5 e)
  | (tapp e T) => tapp (Tsubst_exp T5 X5 e) (Tsubst_typ T5 X5 T)
  | (app e1 e2) => app (Tsubst_exp T5 X5 e1) (Tsubst_exp T5 X5 e2)
  | true => true 
  | false => false 
  | (ite e1 e2 e3) => ite (Tsubst_exp T5 X5 e1) (Tsubst_exp T5 X5 e2) (Tsubst_exp T5 X5 e3)
  | (eq e1 e2) => eq (Tsubst_exp T5 X5 e1) (Tsubst_exp T5 X5 e2)
  | (and e1 e2) => and (Tsubst_exp T5 X5 e1) (Tsubst_exp T5 X5 e2)
end.

Fixpoint tsubst_exp (e_5:exp) (x5:termvar) (e__6:exp) {struct e__6} : exp :=
  match e__6 with
  | (var_b nat) => var_b nat
  | (var_f x) => (if eq_var x x5 then e_5 else (var_f x))
  | (abs T e) => abs T (tsubst_exp e_5 x5 e)
  | (tabs T e) => tabs T (tsubst_exp e_5 x5 e)
  | (tapp e T) => tapp (tsubst_exp e_5 x5 e) T
  | (app e1 e2) => app (tsubst_exp e_5 x5 e1) (tsubst_exp e_5 x5 e2)
  | true => true 
  | false => false 
  | (ite e1 e2 e3) => ite (tsubst_exp e_5 x5 e1) (tsubst_exp e_5 x5 e2) (tsubst_exp e_5 x5 e3)
  | (eq e1 e2) => eq (tsubst_exp e_5 x5 e1) (tsubst_exp e_5 x5 e2)
  | (and e1 e2) => and (tsubst_exp e_5 x5 e1) (tsubst_exp e_5 x5 e2)
end.

Definition Tsubst_binding (T5:typ) (X5:typevar) (b5:binding) : binding :=
  match b5 with
  | (bind_typ T) => bind_typ (Tsubst_typ T5 X5 T)
  | (bind_sub T) => bind_sub (Tsubst_typ T5 X5 T)
end.


Inductive value : exp -> Prop :=
  | value_abs : forall T e1,
      lc_exp (abs T e1) ->
      value (abs T e1)
  | value_tabs : forall T e1,
      lc_exp (tabs T e1) ->
      value (tabs T e1)
  | value_true :
      value (true)
  | value_false :
      value (false)
.

Notation empty := (@nil (atom * binding)).

Definition open_tt T U := open_typ_wrt_typ_rec 0 U T.
Definition open_te e U := open_exp_wrt_typ_rec 0 U e.
Definition open_ee e1 e2 := open_exp_wrt_exp_rec 0 e2 e1.


(** definitions *)

(* defns WFTyp *)
Inductive wf_typ : ctx -> typ -> Prop :=    (* defn wf_typ *)
 | wf_typ_top : forall (G:ctx),
     wf_typ G typ_top
 | wf_typ_true : forall (G:ctx),
     wf_typ G typ_true
 | wf_typ_false : forall (G:ctx),
     wf_typ G typ_false
 | wf_typ_arrow : forall (G:ctx) (T1 T2:typ),
     wf_typ G T1 ->
     wf_typ G T2 ->
     wf_typ G (typ_arrow T1 T2)
 | wf_typ_forall : forall (L:vars) (G:ctx) (T1 T2:typ),
     wf_typ G T1 ->
      ( forall X , X \notin  L  -> wf_typ  (( X ~bind_sub T1 )++ G )   ( open_typ_wrt_typ T2 (typ_tvar_f X) )  )  ->
     wf_typ G (typ_forall T1 T2)
 | wf_typ_union : forall (G:ctx) (T1 T2:typ),
     wf_typ G T1 ->
     wf_typ G T2 ->
     wf_typ G (typ_union T1 T2)
 | wf_typ_var : forall (G:ctx) (X:typevar) (T:typ),
      binds  X (bind_sub T ) G  ->
     wf_typ G (typ_tvar_f X).

(* defns WFEnv *)
Inductive wf_env : ctx -> Prop :=    (* defn wf_env *)
 | wf_env_empty : 
     wf_env  nil 
 | wf_env_sub : forall (G:ctx) (X:typevar) (T:typ),
     wf_env G ->
     wf_typ G T ->
      ~ AtomSetImpl.In  X  (dom  G )  ->
     wf_env  (( X ~bind_sub T )++ G ) 
 | wf_env_typ : forall (G:ctx) (x:termvar) (T:typ),
     wf_env G ->
     wf_typ G T ->
      ~ AtomSetImpl.In  x  (dom  G )  ->
     wf_env  (( x ~bind_typ T )++ G ) .

(* defns JSubTyping *)
Inductive sub : ctx -> typ -> typ -> Prop :=    (* defn sub *)
 | sub_top : forall (G:ctx) (T:typ),
     wf_env G ->
     wf_typ G T ->
     sub G T typ_top
 | sub_refl_true : forall (G:ctx),
     wf_env G ->
     sub G typ_true typ_true
 | sub_refl_false : forall (G:ctx),
     wf_env G ->
     sub G typ_false typ_false
 | sub_refl_tvar : forall (G:ctx) (X:typevar),
     wf_env G ->
     wf_typ G (typ_tvar_f X) ->
     sub G (typ_tvar_f X) (typ_tvar_f X)
 | sub_trans_tvar : forall (G:ctx) (X:typevar) (T2 T1:typ),
      binds  X (bind_sub T1 ) G  ->
     sub G T1 T2 ->
     sub G (typ_tvar_f X) T2
 | sub_arrow : forall (G:ctx) (S1 S2 T1 T2:typ),
     sub G T1 S1 ->
     sub G T2 S2 ->
     sub G (typ_arrow S1 S2) (typ_arrow T1 T2)
 | sub_forall : forall (L:vars) (G:ctx) (S1 S2 T1 T2:typ),
     sub G T1 S1 ->
      ( forall X , X \notin  L  -> sub  (( X ~bind_sub T1 )++ G )   ( open_typ_wrt_typ S2 (typ_tvar_f X) )   ( open_typ_wrt_typ T2 (typ_tvar_f X) )  )  ->
     sub G (typ_forall S1 S2) (typ_forall T1 T2)
 | sub_union_l : forall (G:ctx) (S T2 T1:typ),
     wf_env G ->
     wf_typ G T2 ->
     sub G S T1 ->
     sub G (typ_union S T2) (typ_union T1 T2)
 | sub_union_r : forall (G:ctx) (T1 S T2:typ),
     wf_env G ->
     wf_typ G T1 ->
     sub G S T2 ->
     sub G (typ_union T1 S) (typ_union T1 T2)
 | sub_union_m : forall (G:ctx) (S1 S2 T:typ),
     sub G S1 T ->
     sub G S2 T ->
     sub G (typ_union S1 S2) T.

(* defns JTyping *)
Inductive typing : ctx -> exp -> typ -> Prop :=    (* defn typing *)
 | typing_var : forall (G:ctx) (x:termvar) (T:typ),
     wf_env G ->
      binds  x (bind_typ T ) G  ->
     typing G (var_f x) T
 | typing_abs : forall (L:vars) (G:ctx) (T1:typ) (e:exp) (T2:typ),
      ( forall x , x \notin  L  -> typing  (( x ~bind_typ T1 )++ G )   ( open_exp_wrt_exp e (var_f x) )  T2 )  ->
     typing G (abs T1 e) (typ_arrow T1 T2)
 | typing_app : forall (G:ctx) (e1 e2:exp) (T2 T1:typ),
     typing G e1 (typ_arrow T1 T2) ->
     typing G e2 T1 ->
     typing G (app e1 e2) T2
 | typing_tabs : forall (L:vars) (G:ctx) (T1:typ) (e:exp) (T2:typ),
      ( forall X , X \notin  L  -> typing  (( X ~bind_sub T1 )++ G )   ( open_exp_wrt_typ e (typ_tvar_f X) )   ( open_typ_wrt_typ T2 (typ_tvar_f X) )  )  ->
     typing G (tabs T1 e) (typ_forall T1 T2)
 | typing_tapp : forall (G:ctx) (e:exp) (S T2 T1:typ),
     typing G e (typ_forall T1 T2) ->
     sub G S T1 ->
     typing G (tapp e S)  (open_typ_wrt_typ  T2 S ) 
 | typing_sub : forall (G:ctx) (e:exp) (T S:typ),
     typing G e S ->
     sub G S T ->
     typing G e T
 | typing_true : forall (G:ctx),
     wf_env G ->
     typing G true typ_true
 | typing_false : forall (G:ctx),
     wf_env G ->
     typing G false typ_false
 | typing_eq : forall (G:ctx) (e1 e2:exp) (T1 T2:typ),
     wf_typ G T1 ->
     wf_typ G T2 ->
     typing G e1 T1 ->
     typing G e2 T2 ->
     typing G (eq e1 e2) (typ_union typ_true typ_false)
 | typing_and : forall (G:ctx) (e1 e2:exp),
     typing G e1 (typ_union typ_true typ_false) ->
     typing G e2 (typ_union typ_true typ_false) ->
     typing G (and e1 e2) (typ_union typ_true typ_false).

(* defns JEval *)
Inductive red : exp -> exp -> Prop :=    (* defn red *)
 | red_app1 : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     red e1 e1' ->
     red (app e1 e2) (app e1' e2)
 | red_app2 : forall (v1 e2 e2':exp),
     lc_exp v1 ->
     red e2 e2' ->
     red (app v1 e2) (app v1 e2')
 | red_app_abs : forall (T:typ) (e1 v2:exp),
     lc_typ T ->
     lc_exp (abs T e1) ->
     lc_exp v2 ->
     red (app  ( (abs T e1) )  v2)  (open_exp_wrt_exp  e1 v2 ) 
 | red_tapp : forall (e:exp) (T:typ) (e':exp),
     lc_typ T ->
     red e e' ->
     red (tapp e T) (tapp e' T)
 | red_tapp_tabs : forall (S:typ) (e:exp) (T:typ) (e1:exp),
     lc_typ S ->
     lc_exp (tabs S e) ->
     lc_exp e1 ->
     lc_typ T ->
     red (tapp  ( (tabs S e) )  T)  (open_exp_wrt_typ  e1 T ) 
 | red_if_true : forall (e1 e2:exp),
     lc_exp e2 ->
     lc_exp e1 ->
     red (ite true e1 e2) e1
 | red_if_false : forall (e1 e2:exp),
     lc_exp e1 ->
     lc_exp e2 ->
     red (ite false e1 e2) e2
 | red_if : forall (e e1 e2 e':exp),
     lc_exp e1 ->
     lc_exp e2 ->
     red e e' ->
     red (ite e e1 e2) (ite e' e1 e2)
 | red_eql : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     red e1 e1' ->
     red (eq e1 e2) (eq e1' e2)
 | red_eqr : forall (v1 e2 e2':exp),
     lc_exp v1 ->
     red e2 e2' ->
     red (eq v1 e2) (eq v1 e2')
 | red_eq : forall (v1 v2:exp),
     lc_exp v1 ->
     lc_exp v2 ->
     red (eq v1 v2) true
 | red_andl : forall (e1 e2 e1':exp),
     lc_exp e2 ->
     red e1 e1' ->
     red (and e1 e2) (and e1' e2)
 | red_andr : forall (v1 e2 e2':exp),
     lc_exp v1 ->
     red e2 e2' ->
     red (and v1 e2) (and v1 e2')
 | red_and_false_l : forall (v2:exp),
     lc_exp v2 ->
     red (and false v2) false
 | red_and_false_r : forall (v1:exp),
     lc_exp v1 ->
     red (and v1 false) false
 | red_and_true : 
     red (and true true) true.


(** infrastructure *)
Hint Constructors wf_typ wf_env sub typing red lc_typ lc_binding lc_exp : core.


